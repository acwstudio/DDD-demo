## DDD-demo

[English README](https://github.com/acwstudio/DDD-demo/blob/ddd_v1/README.md)

### Вступление
В данном проекте я попытаюсь на практике создать такую архитектуру приложения Laravel, которая позволит вести
командную разработку средних и больших проектов и облегчит взаимодействие с менеджментом и заказчиками. 

В общих чертах, это будет приложение, разделенное на доменный слой и слой приложения. Внутри каждый слой будет 
подробно детализирован с применением различных паттернов. Для определенности приложение будет E-Shop.

На начальном этапе, планируется создать систему управления пользователями. Пользователи будут двух разных типов:

- **`admins`** Администраторы для управления приложением
- **`customers`** Обычные пользователи приложения

У каждого типа пользователя будет свой круг задач, для осуществления которых будут предусмотрены свои функции 
и ограничения. Это будет два отдельных домена. 

Слой приложения будет включать в себя два типа приложения:

- **`Http`** приложение обрабатывающее запросы **`Http`** клиентов
- **`Console`** приложение для обработки консольных команд

Что и как из этого получится сейчас посмотрим. Чтобы данное описание не распухало, я не буду включать сюда код,
все сделанные изменения очень удобно смотреть в коммитах.

### Файловая структура
Дефолтную структуру Laravel придется кардинально изменить. В процессе ребилдинга будут вырисовываться контуры 
будущего приложения. Начнем с глобальных шагов и вместо одной корневой директории **`app`** создадим три 
новых корневых папки 
- **`app/App`** для слоя приложений
- **`app/Domains`** для доменного слоя
- **`app/Support`** пока не знаю зачем, но думаю пригодится

Теперь отредактируем файл **`composer.json`**. Перенесем все содержимое из директории **`app`**, кроме вновь 
созданных директорий разумеется, в директорию **`app/App`**. Не забываем сделать **`composer dump-autoload`**

Сделаем коммит [#1](https://github.com/acwstudio/DDD-demo/commit/e3a041d5e2873cfcb405c1f8b4d31d1f87511dd1)

Продолжим. Внутри **`App/Http`** создадим две директории:

- **`App/Http/AdminPanel`** панель управления для пользователей **`admins`**
- **`App/Http/Shop`** то, что видят пользователи **`customers`**
 
Внутри созданных директорий, организуем модульную структуру. Первыми модулями будут модули управления 
пользователями **`Admins`** и **`Customers`**.

- **`App/Http/AdminPanel/Admins`** 
- **`App/Http/Shop/Customers`** 

Класс **`App/Http/Controllers/Controller.php`** вынесем в директорию **`App/Http/Controller.php`**

Директорию **`App/Http/Controllers`** перенесем и в **`App/Http/AdminPanel/Admins/Controllers`** и в 
**`App/Http/Shop/Customers/Controllers`**

Сделаем коммит [#2](https://github.com/acwstudio/DDD-demo/commit/41ce7ed6a9d7a4f8a8238d5f53595d6ff3de23ac)

На этом со слоем **`App`** пока остановимся и перейдем к слою **`Domain`** и создадим следующие директории

- **`Domain/Admins/Models`** домен **`Admins`** с директорией для **`Models`**
- **`Domain/Customers/Models`** домен **`Customers`** с директорией для **`Models`**

Дефолтную директорию **`App/Models`** вместе с моделью **`User.php`** удаляем. У нас будет два типа пользователей 
и две модели **`Admin.php`** и **`Customer.php`**. К их созданию перейдем чуть позже. 

Сделаем коммит [#3](https://github.com/acwstudio/DDD-demo/commit/3fc71cd7d93e54dae148d6ac10a18fed8c17aea4)

### Готовим фронтенд

Прежде чем приступить к этому шагу, пофиксил немного грамматику в README.ru.md

Начнем с фронтенда для Shop. У меня есть уже собраный макет со всеми необходимыми **`html`**, **`css`** и 
**`js`** файлами, а также всеми библиотеками и плагинами. Я не имею возможности установить этот макет с помощью
**`npm`** и я сделаю это ручками. Создадим файловую структуру.

- удалим дефолтные **`resources/css`** и **`resources/js`** директории.
- создадим директорию **`resources/shop`** где разместим ассеты темы
- создадим директорию **`resources/views/shop`** куда будем класть шаблоны темы

Некоторые файлы нам будут нужны в директории **`public`**. Копирование нужных файлов в определенные директории 
папки **`public`** будет производится с помощью файла **`webpack.mix.js`**. Для того, чтобы эти файлы не попадали 
в репозиторий, создадим эти директории заранее и разместим там файлы **`.gitignore`**. 

Файловая структура будет постепенно дополняться по мере продвижения проекта, все изменения смотрите в коммитах.

Отредактируем **`webpack.mix.js`** и запустим команду `npm install && npm run dev` 

**Примечание** Директория **`public/shop/images`** автоматически не копируется, картинки являются контентом и 
заполняются ручками (в реале через админку).

Сейчас сделаем стартовую страницу для приложения Shop и отредактируем файл **`routes/web/php`**, указав в роуте 
новый **view** шаблон.

Очень много файлов было создано и отредактировано, внимательно смотрите в коммите

Сделаем коммит [#4](https://github.com/acwstudio/DDD-demo/commit/a4c8e682550375e656d0df9740e2c0c60115d279)

### Несколько слов о регистрации вообще.

То, что предложено в Laravel 8 для аутентификации из коробки, стало уже слишком выморочно и крепко завязано на 
фронтенд технологии. Я беру Laravel чтобы написать серверное приложение, а мне предлагается начать разбираться 
в очередных новомодных фреймворках фронтенда. Хотя, вроде как предлагается пакет **`Fortify`**, который типа
**`frontend agnostic`**. Пакет обеспечивает весь набор возможностей, которые предлагались и раньше, но при этом 
плодит какую-то параллельную реальность c жутким оверхедом. Я так подозреваю, что оверхед этот для согласованной 
работы в составе с **`Jetstream`**, так что так себе **`frontend agnostic`**. Боже, зачем все это??? 

Поэтому отнесем это уродство на помойку и попробуем создать свою систему регистрации и аутентификации через 
нормальное место, а именно, через **`Route`**, **`Controller`** с логикой, вынесенной в отдельные классы, чтобы 
можно было эту логику использовать и в консольном приложении. Учитывая тот факт, что у нас два разных типа 
пользователя которые реализуют каждый свою логику, такой подход будет понятен и предсказуем.

Чтобы фреймворк различал эти два типа, необходимо для каждого из них задать в файле **`config/auth.php`** 
свои **`guard`**, **`provider`** и **`passwords`**

### Аутентификация пользователя типа `customer`

Установим пакет **`laravel-ide-helper`** для нормальной работы **PHPStorm** с фасадами

Создадим модель **`Domain/Customers/Models/Customer.php`** и миграцию для таблицы **`customers`**, выполним
**`php artisan migrate`**

Для заполнения таблицы фейковыми пользователями создадим файлы **`database/factories/CustomerFactory.php`** и 
**`database/seeders/CustomerSeeder.php`**, удалим ненужный **`database/factories/UserFactory.php`**. 

**Примечание** Во время выполнения команды **`php artisan db:seed --class=CustomerSeeder`** выскакивает ошибка 
**`Class 'Database\Factories\Domain\Customers\Models\CustomerFactory' not found`**. Из сообщения видно, что 
неправильно определяется полное имя класса **`CustomerFactory`**. Это связано с тем, что мы используем для
моделей кастомные директории, чтобы пофиксить проблему, надо кое-что дописать в
**`App/Providers/AppSeviceProvider`** подробности см [здесь](https://stackoverflow.com/questions/64445875/laravel-8-vendor-class-illuminate-database-eloquent-factories-factory-cant-re)

Выполним **`php artisan db:seed --class=CustomerSeeder`** и получаем набор фейковых зарегистрированных 
пользователей. Далее редактируем файл **`config/auth.php`**, в котором зададим для пользователя **`customer`** 
свой **`guard`**, **`provider`** и **`passwords`**. Все готово для создания аутентификации.

Сделаем коммит [#5](https://github.com/acwstudio/DDD-demo/commit/5600edb0b7d5a5be022f6260901a6769caa7ba21)

Прежде чем приступить к созданию аутентификации, определим функциональный перечень:

- вывод формы **LogIn**
- валидация данных
- ограничения на количество попыток залогиниться
- аутентификация
- разлогинивание

Чтобы не придумывать все самим, позаимствуем многое из прежних версий **Laravel**.

**Вывод формы LogIn**

- создадим контроллер **`App/Http/Shop/Customers/Controllers/ShopLoginController.php`** с методом 
**`showLoginForm`**
- в файле **`routes/web.php`** укажем роут к этому методу
- создадим шаблон **`resources/views/shop/auth/customer-login.blade.php`** для формы **LogIn**

При создании контроллера я призадумался, а так ли уж необходим **`App/Http/Controller.php`**? Он является 
промежуточным звеном в цепи наследования от вендорного **`Illuminate/Routing/Controller.php`** и внутри себя 
содержит несколько трейтов и больше ничего. Не факт, что мне будут нужны все эти трейты, а если что-то 
потребуется я всегда смогу вставить нужный трейт в конкретный контроллер, и наследовать вендорный класс 
напрямую. Отказываться от вендорного класса не будем, он позволяет применять **`Middlweare`** в контроллерах. 
Пожалуй так и сделаем. Удаляем **`App/Http/Controller.php`** и наследуем вендорный класс.

Набираем в броузере **`http://localhost:8004/login`** Все ОК форма появилась.

Сделаем коммит [#6](https://github.com/acwstudio/DDD-demo/commit/67750e400c3352b2a90c4a96d9e54660cb5765e3)

**Валидация данных из формы**

Создадим класс **`App/Http/Shop/Customers/Requests/ShopLoginRequest.php`** который будет отвечать за валидацию.

В контроллере **`App/Http/Shop/Customers/Controllers/ShopLoginController.php`** создадим пока пустой метод 
**`login`**, внедрим в него созданный **`App/Http/Shop/Customers/Requests/ShopLoginRequest.php`** и вернем 
**`$request->all()`**. В файле **`routes/web.php`** укажем роут к этому методу. Проверим как работает валидация, 
наберем пароль меньше 8 знаков, а затем 8 или больше. Валидация работает.

Сделаем коммит [#7](https://github.com/acwstudio/DDD-demo/commit/110d71b253e407de01621bc1203cefa59ff18dda)

**Ограничения на количество попыток залогиниться**

За основу возьмем трейт **`ThrottlesLogins.php`** из пакета **`laravel/ui`**. Скопипастим его в директорию 
**`App/Http/Shop/Customers/Traits/ThrottlesLogins.php`** нашего проекта и подключим в контроллере
**`App/Http/Shop/Customers/Controllers/ShopLoginController.php`**. Недостающие в контроллере 
**`ShopLoginController.php`** методы для работы с трейтом **`ThrottlesLogins.php`**, возьмем в другом трейте 
**`AuthenticatesUsers`** из того же пакета **`laravel/ui`**.

Дополним код метода **`login`** кодом из трейта **`AuthenticatesUsers`**, но только в той части, которая 
касается работы трейта **`ThrottlesLogins.php`** и не выполняет реальной попытки аутентификации, считая любую 
попытку неудачной просто выводя в браузер строку.

Заполним форму любыми данными и отправим их. Получаем строку с неким текстом в браузере. Обновляем страницу. до 
тех пор, пока нас не вернет на страницу с формой **LogIn** и сообщением об ошибке, что мы превысили количество 
разрешенных попыток и покажет через какое время мы сможем продолжить попытки.

Сделаем коммит [#8](https://github.com/acwstudio/DDD-demo/commit/d1790e7094ad01b5e6c769d067e56aafab9c314a)

**Аутентификация пользователя**

Дополним **`App/Http/Shop/Customers/Controllers/ShopLoginController.php`** необходимым кодом, взятым из 
**`AuthenticatesUsers`** пакета **`laravel/ui`**. Добавим строки и заменим **`return`** в методе 
**`login`** и скопируем с нбольшими исправлениями еще ряд методов. Так же напишем пару строчек своего кода 
(одно свойство и конструктор). Еще один метод возьмем из трейта **`RedirectsUsers`** все того же пакета 
**`laravel/ui`**. 

Поправим путь для редиректа после завершения аутентификации в **`App/Providers/RouteServiceProvider.php`**

Методы связанные с разлогиниванием копировать не будем, их отправим позже в отдельный контроллер, который 
создадим специально для разлогинивания. Так же нам не нужен метод для валидации, потому что у нас есть класс 
**`App/Http/Shop/Customers/Requests/ShopLoginRequest.php`**.

Возьмите из базы данных, какого-нибудь фейкового Customer и залогиньтесь. Если перебросило на главную страницу 
значит аутентификация прошла нормально. Все работает. Попробуйте зайти на страницу `/login`, если сразу 
перебросило обратно на главную, то вы точно аутентифицированы. Чтобы разлогиниться запустите 
**`php artisan db:seed --class=CustomerSeeder`**

Немного подправил **`database/seeders/CustomerSeeder.php`** чтобы при выполнении 
**`php artisan db:seed --class=CustomerSeeder`** выводились emails фейковых Customers. Теперь не надо лезть за 
ними в базу данных.

Сделаем коммит [#9](https://github.com/acwstudio/DDD-demo/commit/7731de0a071a1b18c3bddc106272bb20b87ecae1)

**Разлогинивание пользователя**

Добавим новый роут в файле **`routes/web.php`**. Создадим контроллер
**`App/Http/Shop/Customers/Controllers/ShopLogoutController.php`** и скопируем туда пару-тройку методов из трейта 
**`AuthenticatesUsers`** все того же пакета **`laravel/ui`**. Может что-то подправить надо будет. В принципе, 
разлогинивание готово, осталось только форму и кнопку для отправки запроса на фронтенде сделать.

Доработаем главную страницу **`resources/views/shop/pages/shop.blade.php`** чтобы иметь возможность из меню 
переходить на форму **Log In**, показывать аутентифицированному пользователю кнопки, недоступные гостю, в том 
числе и **Log Out**.

Проверяем все работает, теперь для гостя появился в меню пункт **Log In** и скрыта правая часть с корзиной, а 
для аутентифицированного пользователя скрыта кнопка **Log In**, но открыта корзина и появилась кнопка **Log Out**

Сделаем коммит [#10](https://github.com/acwstudio/DDD-demo/commit/d634a7e5488e4d30a3661bbb9d6159bb6131332b)

### Регистрация пользователя типа `customer`

Определим функциональный перечень:

- вывод формы **Register**
- валидация данных
- верификация по email
- регистрация

**Вывод формы Register**

- создадим контроллер **`App/Http/Shop/Customers/Controllers/ShopRegisterController.php`** с методом 
**`showRegisterForm`**
- в файле **`routes/web.php`** укажем роут к этому методу
- создадим шаблон **`resources/views/shop/auth/customer-register.blade.php`** для формы **Register**

Жмем пункт меню **Register** все работает.

Сделаем коммит #11
